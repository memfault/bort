import static com.memfault.bort.buildsrc.BortSettingsDownloaderKt.getBortSettingsAssetsPath

apply plugin: 'com.android.application'
apply plugin: 'com.squareup.anvil'
apply plugin: 'dagger.hilt.android.plugin'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-kapt'
apply plugin: 'kotlinx-serialization'
apply from: rootProject.file("properties.gradle")
apply plugin: 'common-android'

def keystoreProperties = loadBortKeystoreProperties()
def keystoreFilePath = getKeystoreFilePath()

android {
    namespace 'com.memfault.bort'

    buildFeatures {
        buildConfig = true
    }

    defaultConfig {
        applicationId bortProperty("BORT_APPLICATION_ID")
        manifestPlaceholders = [
                bortControlPermission: bortProperty("BORT_CONTROL_PERMISSION"),
                bortFeatureName: getBortFeatureName()
        ]
        versionCode loadVersionCode() as Integer
        versionName loadVersionName() as String

        buildConfigField "Boolean", "RUNTIME_ENABLE_REQUIRED", bortProperty("RUNTIME_ENABLE_REQUIRED")

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    signingConfigs {
        release {
            keyAlias keystoreProperties['keyAlias']
            keyPassword keystoreProperties['keyPassword']
            storeFile file(keystoreFilePath)
            storePassword keystoreProperties['storePassword']
            v1SigningEnabled bortProperty("V1_SIGNING_ENABLED") as Boolean
            v2SigningEnabled bortProperty("V2_SIGNING_ENABLED") as Boolean
        }
    }

    buildTypes {
        debug {
            signingConfig signingConfigs.release
        }

        release {
            signingConfig signingConfigs.release
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}

kapt {
    correctErrorTypes true
    arguments {
        // This is necessary because of the way we bind Anvil's component to Hilt's.
        arg("dagger.hilt.disableModulesHaveInstallInCheck", "true")
    }
}

dependencies {
    api project(':bort-shared')

    implementation deps.android.work
    implementation deps.android.preference
    // An explicit reference to this transitive dependency fixes a duplicate class error during build.
    implementation deps.android.viewmodel

    implementation deps.serialization.json
    implementation deps.serialization.converter

    implementation deps.result
    implementation deps.retrofit
    implementation deps.okhttp
    implementation deps.okio

    implementation deps.jblake2

    implementation deps.dagger.hilt
    kapt deps.dagger.hilt.compiler

    // Required for unit tests to access JSONObject
    testImplementation deps.test.json
    testImplementation deps.test.mockWebServer
    testImplementation deps.test.robolectric
    testImplementation deps.test.androidx.test
}

import java.nio.file.Paths

tasks.register("exportPem", Exec) {
    commandLine 'keytool',
            '-export',
            '-rfc',
            '-keystore', keystoreFilePath,
            '-alias', keystoreProperties['keyAlias'],
            '-file', Paths.get(rootDir.toString(), "MemfaultBort.x509.pem"),
            '-storepass', keystoreProperties['storePassword']
}

afterEvaluate {
    tasks.named("assembleRelease").configure {
        finalizedBy tasks.named("exportPem")
        doLast {
            copy {
                from file("$buildDir/outputs/apk/release/bort-release.apk")
                into rootDir
                rename 'bort-release.apk', 'MemfaultBort.apk'
            }
        }
    }
    tasks.named("assembleDebug").configure {
        finalizedBy tasks.named("exportPem")
    }
}
